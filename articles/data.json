{"articles":[{"title":"初识 React 中的 High Order Component","tags":["React"],"date":"Feb 14, 2016","id":"know-hoc"},{"title":"写一个自己的 Yeoman Generator","tags":["Yeoman"],"date":"Feb 14, 2016","id":"write-yeoman-generator"}],"contents":[{"id":"know-hoc","articleId":"know-hoc","content":"<p>我们都知道，如果使用ES6 Component语法写React组件的话，mixin是不支持的。而mixin作为一种抽象和共用代码的方案，许过库（比如<code>react-router</code>）都依赖这一功能，自己的项目中可能都或多或少有用到mixin来尽量少写重复代码。</p>\n<p>如果希望使用ES6 Component，有希望可以用一个像mixin一样的方案的话，可以使用<code>react-mixin</code>这样的库，就有种hack的感觉。这里介绍一个新的方案：High Order Component。</p>\n<h2 id=\"-high-order-component-\">什么是High Order Component？</h2>\n<p>High Order Component，下面统一简称为HOC。我理解的HOC实际上是这样一个函数：</p>\n<pre><code>hoc :: ReactComponent -&gt; ReactComponent\n</code></pre><p>它接受一个ReactComponent，并返回一个新的ReactComponent，这一点颇有函数式编程的味道。由于是一个抽象和公用代码的方案，这个新的ReactComponent主要包含一些共用代码的逻辑或者是状态，用一个例子来解释更加直观：</p>\n<pre><code class=\"lang-js\">const connect = (mapStateFromStore) =&gt; (WrappedComponent) =&gt; {\n  class InnerComponent extends Component {\n\n    static contextTypes = {\n      store: T.object\n    }\n\n    state = {\n      others: {}\n    }\n\n    componentDidMount () {\n      const { store } = this.context\n      this.unSubscribe = store.subscribe(() =&gt; {\n        this.setState({ others: mapStateFromStore(store.getState()) }\n      })\n    }\n\n    componentWillUnmount () {\n      this.unSubscribe()\n    }\n\n    render () {\n      const { others } = this.state\n      const props = {\n        ...this.props,\n        ...others\n      }\n      return &lt;WrappedComponent {...props} /&gt;\n    }\n  }\n\n  return InnerComponent\n}\n</code></pre>\n<p>这个例子中定义的connect函数其实和<code>react-redux</code>中的connect差不多，我们发现它在内部定义了一个新的ReactComponent并将其返回，它的职责是在订阅store的改变，并将改变传递给子组件，在unmount的时候擦好屁股。这个case和常用的StoreMixin和类似。</p>\n<p><strong>始终要记住的是，HOC最终返回的是一个新的ReactComponent。</strong></p>\n<p>要使用HOC的话可以这样：</p>\n<pre><code class=\"lang-js\">class MyContainer extends Component {\n  ...\n}\n\nexport connect(() =&gt; ({}))(MyContainer)\n</code></pre>\n<p>其实我们还发现HOC的函数类型和class decorator是一样的，所以可以这样：</p>\n<pre><code class=\"lang-js\">@connect(() =&gt; ({}))\nclass MyContainer extends Component {\n  ...\n}\n\nexport MyContainer\n</code></pre>\n<p>但是<strong>HOC不是decorator</strong>，不能保证decorator最终一定进入ES的规范中，然而HOC始终是那个函数。</p>\n<h2 id=\"-mixin-\">与mixin作比较</h2>\n<p>既然HOC的目的和mixin类似，那么我们来比较下这两种方案的区别：</p>\n<p>首先，<strong>mixin是react亲生的，而HOC是社区实践的产物</strong>。其实这一点无关紧要，关键是讨论方案是否给开发带来便利，而且从趋势来看，并不看好mixin。</p>\n<blockquote>\n<p>Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts.</p>\n</blockquote>\n<p>不过我们还是先来看下mixin的使用场景：</p>\n<ul>\n<li>Lifecycle Hook</li>\n<li>State Provider</li>\n</ul>\n<p>第一个应用场景Lifecycle Hook通常是在React组件生命周期函数中做文章，最典型的就是对Store的监听和保证unmount时候取消监听。第二个应用场景State Provider，典型的例子就是<code>react-router</code>，它所提供的几个mixin都是route信息的提供者。复杂的mixin则是两者的结合了。</p>\n<p>回到HOC，对于Lifecycle Hook而言，由于本身就返回一个新的ReactComponent，这一点毫无压力。对于State Provider而言，可以通过新的ReactComponent的state来维护。</p>\n<p>但是：</p>\n<p><strong>两者在生命周期上有差异。</strong>这是我的测试结果，其中hoc表示HOC返回的新的ReactComponent，app表示的是WrappedComponent：</p>\n<pre><code class=\"lang-text\">hoc componentWillMount\napp componentWillMount\napp componentDidMount\nhoc componentDidMount\n</code></pre>\n<p><em>注：这里的componentWillMount是在constructor中输出的。</em></p>\n<p>然后如果在HOC返回的新组件中更新状态的话：</p>\n<pre><code class=\"lang-text\">hoc componentWillUpdate\napp componentWillReceiveProps\napp componentWillUpdate\napp componentDidUpdate\nhoc componentDidUpdate\n</code></pre>\n<p>最后是unmount的部分：</p>\n<pre><code class=\"lang-text\">hoc componentWillUnmount\napp componentWillUnmount\n</code></pre>\n<p>大家自行和mixin比较下吧。其实得到这样的结果是很正常的，熟悉React父子组件之间生命周期关系的同学一定不会陌生。</p>\n<p><strong>暴露API的方式不同。</strong>在使用mixin时，通过会添加一个方法，比如<code>StoreListenMixin</code>提供了一个<code>this.listen</code>方法，又或者<code>react-router</code>的<code>Lifecycle</code>需要我们实现<code>routerWillLeave</code>方法。而如果是HOC的话，从开头的例子可以看出，任何API都是通过属性传递的方式传递给WrappedComponent的。</p>\n<h2 id=\"hoc-\">HOC实践</h2>\n<p>如果大家用Redux的话，<code>react-redux</code>中的connect就算是HOC了。另外，这段来自<code>react-mixin</code>的文字：</p>\n<blockquote>\n<p>90% of the time you don&#39;t need mixins, in general prefer composition via high order components. For the 10% of the cases where mixins are best (e.g. PureRenderMixin and react-router&#39;s Lifecycle mixin), this library can be very useful.</p>\n</blockquote>\n<p><code>react-router</code>始终对mixin有依赖，不过<code>react-mixin</code>提供了decorate方法，让mixin可以想HOC一样使用：</p>\n<pre><code class=\"lang-js\">@reactMixin.decorate(mixin)\nclass AnotherComponent extends Component {\n  ...\n}\n</code></pre>\n<p><a href=\"https://github.com/acdlite/recompose\">recompose</a>这个库可以关注下，里面有大量的HOC实现可以尝试尝试，这个库我也刚接触，就不多展开了。</p>\n<p>安利下我的<a href=\"https://github.com/leozdgao/react-script-loader\">react-async-script-loader</a>，用来异步加载依赖脚本的HOC，可以关注下，欢迎提issue。</p>\n<h2 id=\"-\">存在的问题</h2>\n<p>这是我在实践中遇到的两个问题，可能之后会再更新：</p>\n<p><strong>HOC导致内部ref丢失。</strong>在实践的时候，通常HOC都是“隐身”的，比如：</p>\n<pre><code class=\"lang-js\">// Editor.jsx\n@scriptLoader(...)\nclass Editor extends Component {\n  ...\n}\n\nexport default Editor\n\n// --------------------------------------\n\n// Form.jsx\nimport Editor from &#39;./Editor.jsx&#39;\n\n&lt;Editor ref=&quot;editor&quot; /&gt;\n</code></pre>\n<p>这里的<code>this.refs.editor</code>返回的是什么？注意HOC返回的是一个新的Component，所以这里的ref指向的是新的Component，那么如果你在Editor组件上定义一些public的方法的话，通过<code>this.refs.editor</code>是无法调用到的。</p>\n<p>解决办法是定义一个<code>getInnerInstance()</code>来返回内部WrappedComponent的ref，不过并不能要求第三方库的HOC都这样实现，所以这里算是有一个坑，不能算真正解决。</p>\n<p><strong>componentWillReceiveProps失控</strong>。由于HOC返回的新组件是通过给子组件传递属性的方式来传递状态的改变的，那么如果应用过多的HOC的话，可能导致<code>componentWillReceiveProps</code>里的逻辑变的难以维护。可能可以通过自己写一些utility函数来减压，不过始终是一个隐患。</p>\n<p>最后，HOC由于并不是官方解决方案，遇到坑的原因主要也是缺乏一个统一的Convention，不过观察下来HOC是大势所趋，还在持续观望中，大家对HOC有任何看法的话，欢迎交流。</p>\n<h2 id=\"-issue\">相关文章和issue</h2>\n<p><a href=\"https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md\">https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md</a>\n<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.trp9l55l0\">https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.trp9l55l0</a>\n<a href=\"https://github.com/facebook/react/issues/2669\">https://github.com/facebook/react/issues/2669</a>\n<a href=\"https://github.com/facebook/react/issues/4213\">https://github.com/facebook/react/issues/4213</a></p>\n"},{"id":"write-yeoman-generator","articleId":"write-yeoman-generator","content":"<p>由于自己经常会写一些 demo，或者学习新工具库的使用，然后又比较依赖 npm 的模块管理（这个是重点）和 webpack 的代码打包功能，所以每次都要创建一个目录结构，复制各种 <code>.rc</code> 文件，复制 webpack 的配置文件，复制一个应用了 webpack dev 中间件的 express server，每次都要这样，让我心里很烦。</p>\n<p>我一直知道 yeoman 这个东西，不过找不到自己喜欢的 generator，简单浏览过 generator 的文档，感觉很麻烦，不易上手，就一直没学。最近在新的项目组，我又定义了一套开发的目录规范，为了给自己和团队的其他人提供开发上的便利，于是决定好好学写 Yeoman Generator。</p>\n<p>本文将介绍一个基本的 Yeoman Generator 的写法，并分享一些开发中的注意点。</p>\n<h2 id=\"yeoman-\">Yeoman 是干什么的？</h2>\n<p>简单介绍下 Yeoman，它是一个脚手架生成工具，比如在之前写 ASP.NET MVC 的时候，Visual Studio 会给你选模板，然后生成一个项目的基本结构（脚手架），这对提升开发体验是很有帮助的，节省了重复劳动。然而前端没有什么 IDE（WebStorm？或许吧），没有一个固定的开发模式，可能你喜欢 jshint，我想用 eslint，你觉得 angular 顺手，我觉得 vue 更合适，这时就可以使用 Yeoman 这个工具，生成一个 <strong>适合自己技术栈</strong> 的脚手架，需要的一些文件都预先生成好，给自己省点事。</p>\n<p>而 Yeoman Generator 则定义了一个脚手架应该如何生成，所以我们可以去 <a href=\"http://yeoman.io/generators/\">这个网站</a> 找适合自己的 Generator，如果没有的话，就自己动手吧。</p>\n<p>然后这里是安装和使用的命令，不具体介绍它的使用了，想学的话可以去 <a href=\"http://yeoman.io/\">它的官网</a> 看看。</p>\n<pre><code class=\"lang-shell\">&gt; npm install -g yo\n&gt; npm install -g generator-angular\n\n&gt; yo angular\n</code></pre>\n<h2 id=\"-\">自己的需求</h2>\n<p>先说下自己的需求吧，我希望它可以：</p>\n<ul>\n<li>满足自己的技术栈：express、webpack、react、babel、eslint、travis</li>\n<li>自动生成并安装依赖</li>\n<li>灵活性，即可以生成一个适合写 demo 的小脚手架，也可以生成一个 WebApp 的复杂脚手架，同时，在需要的时候可以只生成一份 <code>.babelrc</code></li>\n<li>组合性，多个脚手架可以组合，可复用</li>\n</ul>\n<p>很高兴的是，Yeoman 完全可以实现我的需求。</p>\n<h2 id=\"-yeoman-generator-\">开始写 Yeoman Generator 了</h2>\n<p>Yeoman 给我们提供了一个用来写脚手架的脚手架 <a href=\"https://github.com/yeoman/generator-generator\">generator-generator</a>，我们可以从它开始。</p>\n<blockquote>\n<p>由于生成出来的项目依赖 nsp 服务，我在 npm prepublish 阶段的时候发生了域名解析错误的问题，如果遇到了类似的问题，就把 package.json 里的 prepublish 删掉吧。</p>\n</blockquote>\n<p>假设我要写一个 Generator 叫做 Butler（管家的意思），那么，根据 Yeoman 的规定，你需要将这个 node 模块的名字命名为 <code>generator-*</code>，所以我命名为 <code>generator-butler</code>，如果你是通过 <code>generator-generator</code> 生成的目录结构，那么可以进入到 <code>generator-butler</code> 目录中，运行 <code>npm link</code>，就可以开始使用你的 Generator 啦。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005YR2J3gw1f0y6nfy1btj31340n5gp0.jpg\" alt=\"\"></p>\n<p>Yeoman Generator 高度依赖目录结构，意思是它的行为由你的目录结构决定，怎么说？比如：</p>\n<pre><code class=\"lang-shell\">yo butler\nyo butler:babel\n</code></pre>\n<p>第一条命令会找你代码目录中的 <code>app</code> 目录，第二条命令会找你目录中的 <code>babel</code> 目录。这样的一个个目录称为 <code>sub-generator</code>，默认的 <code>sub-generator</code> 名字是 app。</p>\n<p>为什么要这样呢？我分享我的想法，我觉得这是出于对可组合性角度考虑的，我们可以定义多个 <code>sub-generator</code>，比如我有多个 <code>sub-generator</code> 分别单独管理：babel、eslint、webpack，同时 app 这个默认的 <code>sub-generator</code> 是这几个 <code>sub-generator</code> 的组合，所以：</p>\n<ul>\n<li>同时可以生成整个项目的结构，也可以（比如）只生成 babel 配置文件</li>\n<li>各个模块单独管理，易于维护</li>\n</ul>\n<p>非常符合自己比较认同的一句话：</p>\n<blockquote>\n<p>perfer composition over inheritance</p>\n</blockquote>\n<p>默认 <code>sub-generator</code> 是基于项目根目录找的，也可以换一个目录（比如 generators），就像例子中那样统一管理，要实现这个，需要在 <code>package.json</code> 中加一个属性：</p>\n<pre><code class=\"lang-json\">{\n  ...\n  &quot;files&quot;: [\n    &quot;generators&quot;\n  ],\n  ...\n}\n</code></pre>\n<p>如何实现组合，下面会说到。</p>\n<blockquote>\n<p>sub-generator 的加载似乎并不是直接应用 node 的模块 resolve 机制，我本来以为是一个文件夹模块加载方式，我试着直接创建文件模块，它就不认了，看来是必须使用文件夹模块的方式的。</p>\n</blockquote>\n<h3 id=\"-\">基本结构</h3>\n<p>Yeoman 为我们提供了 Generator 的基类，于是：</p>\n<pre><code class=\"lang-js\">var generators = require(&#39;yeoman-generator&#39;)\n\nmodule.exports = generators.Base.extend({\n  constructor: function () {\n    generators.Base.apply(this, arguments)\n\n    // your logic\n  }\n})\n</code></pre>\n<blockquote>\n<p>这边用的 OOP 用的是 <code>classical inheritance</code> 的风格，使用了 <a href=\"https://github.com/SBoudrias/class-extend\">class-extend</a> 这个模块，有兴趣的可以看看。</p>\n</blockquote>\n<p>我们需要做的就是定义它的方法就行了。那么要怎么定义呢？</p>\n<h3 id=\"-\">运行周期</h3>\n<p>一个 Yeoman Generator 被创建后（构造函数必然是最先被调用的），会依次调用它原型上的方法，且每一个方法中的 this 都被绑定为 Generator 实例本身，调用的顺序如下：</p>\n<ol>\n<li><strong>initializing</strong> - 初始化一些状态之类的，通常是和用户输入的 <code>options</code> 或者 <code>arguments</code> 打交道，这个后面说。</li>\n<li><strong>prompting</strong> - 和用户交互的时候（命令行问答之类的）调用。</li>\n<li><strong>configuring</strong> - 保存配置文件（如 <code>.babelrc</code> 等）。</li>\n<li><strong>default</strong> - 其他方法都会在这里按顺序统一调用。</li>\n<li><strong>writing</strong> - 在这里写一些模板文件。</li>\n<li><strong>conflicts</strong> - 处理文件冲突，比如当前目录下已经有了同名文件。</li>\n<li><strong>install</strong> - 开始安装依赖。</li>\n<li><strong>end</strong> - 擦屁股的部分... Say Goodbye maybe...</li>\n</ol>\n<p>上面只是调用顺序，后面的说明是建议，也就是说你完全可以在 <strong>install</strong> 的部分写文件，在 <strong>configuring</strong> 的时候就开始安装依赖，不过这样的话，就不保证行为的正确性了，更不要说维护上的问题了，所以，别这样，按照它的强制范式来吧。</p>\n<p>这些运行周期方法，除了可以是函数外，还可以是对象，我以 babel 的 <code>sub-generator</code> 为例子：</p>\n<pre><code class=\"lang-js\">writing: {\n  files: function () {\n    // 写 `.babelrc` 文件\n  },\n  pkg: function () {\n    // 给 package.json 文件上添加依赖项\n  }\n}\n</code></pre>\n<p>对象里的每一个函数会被依次执行。是写成一个函数，还是分成多个函数写成一个对象，都可以，我个人倾向于后者。</p>\n<p><strong>关于依赖 Object 属性的顺序</strong></p>\n<p>偏一下题，注意 default 这个部分，【按顺序执行】？</p>\n<p>首先从 ECMAScript 标准来说，并不保证对象属性的顺序，之前开发遇到过坑：</p>\n<blockquote>\n<p>4.3.3 Object\nAn object is a member of the type Object. It is <strong>an unordered collection</strong> of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.</p>\n</blockquote>\n<p>自己在写 Generator 的时候也没怎么自定义方法（就是 default 这步是空的），都是依赖它的运行周期函数，而 Yeoman Generator 目前是依赖于对象属性的插入顺序的（相当于运行到 default 这步的时候），这里不多评价，如果平时开发希望在遍历集合的时候，保证遍历顺序的话，应该使用数组或者是ECMAScript 2015 中新增的 Map 对象：</p>\n<blockquote>\n<p>A Map iterates its elements in insertion order, whereas iteration order is not specified for Objects.</p>\n</blockquote>\n<h3 id=\"-\">和用户的交互</h3>\n<p>Yeoman 提供了多个方式来灵活定制你的脚手架：</p>\n<p><strong>Arguments 和 Options</strong></p>\n<p>比如：</p>\n<blockquote>\n<p>yo butler MyProject --react --author leozdgao</p>\n</blockquote>\n<p>其中，<code>MyProject</code> 就一个第一个定义的 argument，而 <code>react</code> 和 <code>author</code> 就是 options，值分别是 true 和 leozdgao。</p>\n<p>对于 arguments 来说，不需要输入 key，键值对的对应关系是根据定义顺序来的。对于 options 来说，可以分别出入 key 和 value。</p>\n<p>定义 arguments 和 options 的方式是类似的：</p>\n<pre><code class=\"lang-js\">this.option(&#39;react&#39;, {\n  type: Boolean,\n  desc: &quot;need to use React or not.&quot;,\n  defaults: false\n})\nthis.arguments(&#39;name&#39;, {\n  type: String,\n  desc: &quot;your project name&quot;,\n  required: true\n})\n</code></pre>\n<p>从参数名上就看的明白是什么意思了，不多说了。</p>\n<p>定义 arguments 或者 options 写在哪里都行，不过为了保证在任何地方都能正常访问到，建议放在构造函数中。如果要访问的话：</p>\n<pre><code class=\"lang-js\">this.options[&#39;react&#39;] // options 通过 options 属性获取\nthis.name // 是的，arguments 会直接作为 generator 的一个属性\n</code></pre>\n<p>arguments 和 options 的帮助信息会在定义后自动生成（如果它们不是在构造函数中被定义的话，帮助信息就无法自动生成）：</p>\n<pre><code class=\"lang-shell\">&gt; yo butler --help\n</code></pre>\n<blockquote>\n<p>不要信你定义的 <code>type</code>，其实这里并没有根据你定义的 <code>type</code> 进行转换，如果对数据类型有要求的话，这里要当心。</p>\n</blockquote>\n<p><strong>CLI 交互</strong></p>\n<p>使用与用户问答交互的方式是比较有趣的，同时也不用记住要传的参数，Yeoman 提供了 API 来让我们快速实现 CLI 交互：</p>\n<pre><code class=\"lang-js\">module.exports = generators.Base.extend({\n  prompting: function () {\n    var done = this.async();\n    this.prompt({\n      type    : &#39;input&#39;,\n      name    : &#39;name&#39;,\n      message : &#39;Your project name&#39;,\n      default : this.appname // Default to current folder name\n    }, function (answers) {\n      this.log(answers.name);\n      done();\n    }.bind(this));\n  }\n});\n</code></pre>\n<p>内部直接使用了 <code>Inquirer.js</code>，API不变，这里就不多写了，大家可以直接看 <a href=\"https://github.com/SBoudrias/Inquirer.js\">文档</a>。</p>\n<blockquote>\n<p>可以发现 Yeoman 处理异步的方式是声明回调并显示调用。</p>\n</blockquote>\n<h3 id=\"-\">项目模板</h3>\n<p>生成脚手架就是拷贝模板文件，你可以定义你的模板文件。这里涉及到两个文件夹，一个是你希望生成脚手架的目标文件夹，一个是模板所在的文件夹。Yeoman 提供了 API 来快速获取它们，来看个例子，我希望根据 <code>react</code> 这个 option 来决定是否在 presets 中添加 <code>react</code>：</p>\n<pre><code class=\"lang-js\">writing: function () {\n  this.fs.copyTpl(\n    this.templatePath(&#39;.babelrc&#39;),\n    this.destinationPath(&#39;.babelrc&#39;),\n    { needReact: this.options.react }\n  )\n}\n</code></pre>\n<p>获取目标文件夹目录可以用 <code>generator.destinationPath()</code>，传入的参数和 <code>path.join()</code> 是一样的。获取模板文件夹目录可以用 <code>generator.sourceRoot()</code>，默认是 Generator 代码目录下的 <code>./templates</code>，也可以重写：<code>generator.sourceRoot(&#39;new/template/path&#39;)</code>。如果是拼模板文件路径的话，就用 <code>generator.templatePath(&#39;app/index.js&#39;)</code>。</p>\n<p>Yeoman 给我们提供了方便的处理文件的工具，可以通过 <code>fs</code> 属性调用，其实就是用了 <a href=\"https://github.com/sboudrias/mem-fs-editor\">mem-fs-editor</a> 这个库，可以直接看它的 API 说明，这里不多说了，要提一下的是模板引擎用的时 EJS。</p>\n<p>这份是我对应上面例子的模板文件：</p>\n<pre><code class=\"lang-json\">{\n  &quot;presets&quot;: [\n    &quot;es2015&quot;, &quot;stage-0&quot;\n    &lt;% if (needReact) { %&gt;\n    , &quot;react&quot;\n    &lt;% } %&gt;\n  ]\n}\n</code></pre>\n<p>例子里调用了 <code>copyTpl</code>，如果觉得不用经过模板引擎，可以直接用 <code>copy</code> 原样拷贝。</p>\n<h3 id=\"-\">组合</h3>\n<blockquote>\n<p>这里的组合只是概念，并不是按照函数式的方式实现的。</p>\n</blockquote>\n<p>要实现组合，其实很简单，在希望调用的地方调用 <code>generator.composeWith</code> 即可，直接上例子：</p>\n<pre><code class=\"lang-js\">default: function () {\n  // execute other sub-generators\n  this.composeWith(&#39;butler:babel&#39;, {\n    options: { react: this.options.react }\n  }, {\n    local: require.resolve(&#39;../babel&#39;)\n  })\n  // select a License\n  this.composeWith(&#39;license&#39;, {\n    options: {\n      name: this.props.authorName,\n      email: this.props.authorEmail,\n      website: this.props.authorUrl\n    }\n  }, {\n    local: require.resolve(&#39;generator-license/app&#39;)\n  })\n}\n</code></pre>\n<p>例子里分别是组合本地的一个 <code>sub-generator</code>，和一个外部的 <code>Generator</code>，我选择在 default 这个运行周期调用组合。</p>\n<p>composeWith 接受三个参数，第一个参数一个名字，写什么都行，不过最好写要被组合的 <code>Generator</code> 的名字。第二个参数是传入 <code>options</code> 和 <code>arguments</code>。第三个参数 settings，只用 local 和 link 两个选项，local 是用来定位要组合的 <code>Generator</code> 的位置的，link 还不知道，没怎么看懂它的 <a href=\"http://yeoman.io/generator/Base.html\">说明文档</a>。</p>\n<h3 id=\"-\">自动安装依赖</h3>\n<p>恩，差点忘记这个，很简单，就是函数调用：</p>\n<pre><code class=\"lang-js\">install: function() {\n  this.npmInstall([ &#39;lodash&#39; ], { &#39;saveDev&#39;: true });\n}\n</code></pre>\n<p>在任何地方调用都是可以的，Yeoman 会统一在进入 install 阶段的时候统一执行。如果还有在用 bower 的同学的话可以用这个：<code>generator.bowerInstall()</code>。</p>\n<h2 id=\"-\">最后</h2>\n<p>好了，基本上完了，如果什么地方写错了，还望指出。自己的 <a href=\"https://github.com/leozdgao/butler\">butler</a>，还在开发中，可以参考，另外我其实也是参考 <a href=\"https://github.com/yeoman/generator-node\">generator-node</a> 的，或者自己找些 Yeoman Generator 的源码学学，个人认为使用 npm 作为包管理是趋势（暂时也应该没有终极方案，还是要依赖 bundle 工具），那么 bundle 工具就是不可或缺的了，写个脚手架还是挺有帮助的，希望本文对大家有帮助。</p>\n<p>然后是一些工具库推荐：</p>\n<ul>\n<li><a href=\"https://github.com/jozefizso/generator-license\">generator-license</a> - 选择 License 的 Generator</li>\n<li><a href=\"https://github.com/SBoudrias/Inquirer.js\">inquirer</a> - 提供命令行交互的工具</li>\n<li><a href=\"https://github.com/SBoudrias/inquirer-npm-name\">inquirer-npm-name</a> - 帮助查询模块名在 npm 上是否冲突，和 Yeoman 完美融合</li>\n<li><a href=\"https://github.com/yeoman/yosay\">yosay</a> - 在命令行输出信息的时候，同时输出 Yeoman 的卡通人物...</li>\n</ul>\n<p>一些文档的链接：</p>\n<ul>\n<li><a href=\"http://yeoman.io/generator/Base.html\">Yeoman Generator API</a></li>\n<li><a href=\"http://yeoman.io/authoring/\">Get Started</a></li>\n<li><a href=\"http://yeoman.io/\">Yeoman 官网</a></li>\n</ul>\n<p>Yeoman 团队目前在开发一个 <a href=\"https://github.com/yeoman/yeoman-app\">Yeoman App</a>，就是一个 GUI 版的 yo 吧，总之还是期待的。</p>\n"}]}