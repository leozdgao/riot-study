{"articles":[{"title":"初识 React 中的 High Order Component","tags":["React"],"date":"Feb 14, 2016","id":"know-hoc","abstract":"<p>我们都知道，如果使用ES6 Component语法写React组件的话，mixin是不支持的。而mixin作为一种抽象和共用代码的方案，许过库（比如<code>react-router</code>）都依赖这一功能，自己的项目中可能都或多或少有用到mixin来尽量少写重复代码。</p>\n<p>如果希望使用ES6 Component，有希望可以用一个像mixin一样的方案的话，可以使用<code>react-mixin</code>这样的库，就有种hack的感觉。这里介绍一个新的方案：High Order Component。</p>\n"},{"title":"为什么说DOM操作很慢","tags":["前端开发"],"date":"Feb 14, 2016","id":"why-dom-slow","abstract":"<p>一直都听说DOM很慢，要尽量少的去操作DOM，于是就想进一步去探究下为什么大家都会这样说，在网上学习了一些资料，这边整理出来。</p>\n<p>首先，DOM对象本身也是一个js对象，所以严格来说，并不是操作这个对象慢，而是说操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）。下面主要先介绍下这些浏览器行为，阐述一个页面是怎么最终被呈现出来的，另外还会从代码的角度，来说明一些不好的实践以及一些优化方案。</p>\n"},{"title":"写一个自己的 Yeoman Generator","tags":["Yeoman"],"date":"Feb 14, 2016","id":"write-yeoman-generator","abstract":"<p>由于自己经常会写一些 demo，或者学习新工具库的使用，然后又比较依赖 npm 的模块管理（这个是重点）和 webpack 的代码打包功能，所以每次都要创建一个目录结构，复制各种 <code>.rc</code> 文件，复制 webpack 的配置文件，复制一个应用了 webpack dev 中间件的 express server，每次都要这样，让我心里很烦。</p>\n<p>我一直知道 yeoman 这个东西，不过找不到自己喜欢的 generator，简单浏览过 generator 的文档，感觉很麻烦，不易上手，就一直没学。最近在新的项目组，我又定义了一套开发的目录规范，为了给自己和团队的其他人提供开发上的便利，于是决定好好学写 Yeoman Generator。</p>\n<p>本文将介绍一个基本的 Yeoman Generator 的写法，并分享一些开发中的注意点。</p>\n"}],"contents":[{"id":"know-hoc","articleId":"know-hoc","content":"<p>我们都知道，如果使用ES6 Component语法写React组件的话，mixin是不支持的。而mixin作为一种抽象和共用代码的方案，许过库（比如<code>react-router</code>）都依赖这一功能，自己的项目中可能都或多或少有用到mixin来尽量少写重复代码。</p>\n<p>如果希望使用ES6 Component，有希望可以用一个像mixin一样的方案的话，可以使用<code>react-mixin</code>这样的库，就有种hack的感觉。这里介绍一个新的方案：High Order Component。</p>\n<!-- more -->\n<h2 id=\"-high-order-component-\">什么是High Order Component？</h2>\n<p>High Order Component，下面统一简称为HOC。我理解的HOC实际上是这样一个函数：</p>\n<pre><code>hoc :: ReactComponent -&gt; ReactComponent\n</code></pre><p>它接受一个ReactComponent，并返回一个新的ReactComponent，这一点颇有函数式编程的味道。由于是一个抽象和公用代码的方案，这个新的ReactComponent主要包含一些共用代码的逻辑或者是状态，用一个例子来解释更加直观：</p>\n<pre><code class=\"lang-js\">const connect = (mapStateFromStore) =&gt; (WrappedComponent) =&gt; {\n  class InnerComponent extends Component {\n\n    static contextTypes = {\n      store: T.object\n    }\n\n    state = {\n      others: {}\n    }\n\n    componentDidMount () {\n      const { store } = this.context\n      this.unSubscribe = store.subscribe(() =&gt; {\n        this.setState({ others: mapStateFromStore(store.getState()) }\n      })\n    }\n\n    componentWillUnmount () {\n      this.unSubscribe()\n    }\n\n    render () {\n      const { others } = this.state\n      const props = {\n        ...this.props,\n        ...others\n      }\n      return &lt;WrappedComponent {...props} /&gt;\n    }\n  }\n\n  return InnerComponent\n}\n</code></pre>\n<p>这个例子中定义的connect函数其实和<code>react-redux</code>中的connect差不多，我们发现它在内部定义了一个新的ReactComponent并将其返回，它的职责是在订阅store的改变，并将改变传递给子组件，在unmount的时候擦好屁股。这个case和常用的StoreMixin和类似。</p>\n<p><strong>始终要记住的是，HOC最终返回的是一个新的ReactComponent。</strong></p>\n<p>要使用HOC的话可以这样：</p>\n<pre><code class=\"lang-js\">class MyContainer extends Component {\n  ...\n}\n\nexport connect(() =&gt; ({}))(MyContainer)\n</code></pre>\n<p>其实我们还发现HOC的函数类型和class decorator是一样的，所以可以这样：</p>\n<pre><code class=\"lang-js\">@connect(() =&gt; ({}))\nclass MyContainer extends Component {\n  ...\n}\n\nexport MyContainer\n</code></pre>\n<p>但是<strong>HOC不是decorator</strong>，不能保证decorator最终一定进入ES的规范中，然而HOC始终是那个函数。</p>\n<h2 id=\"-mixin-\">与mixin作比较</h2>\n<p>既然HOC的目的和mixin类似，那么我们来比较下这两种方案的区别：</p>\n<p>首先，<strong>mixin是react亲生的，而HOC是社区实践的产物</strong>。其实这一点无关紧要，关键是讨论方案是否给开发带来便利，而且从趋势来看，并不看好mixin。</p>\n<blockquote>\n<p>Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts.</p>\n</blockquote>\n<p>不过我们还是先来看下mixin的使用场景：</p>\n<ul>\n<li>Lifecycle Hook</li>\n<li>State Provider</li>\n</ul>\n<p>第一个应用场景Lifecycle Hook通常是在React组件生命周期函数中做文章，最典型的就是对Store的监听和保证unmount时候取消监听。第二个应用场景State Provider，典型的例子就是<code>react-router</code>，它所提供的几个mixin都是route信息的提供者。复杂的mixin则是两者的结合了。</p>\n<p>回到HOC，对于Lifecycle Hook而言，由于本身就返回一个新的ReactComponent，这一点毫无压力。对于State Provider而言，可以通过新的ReactComponent的state来维护。</p>\n<p>但是：</p>\n<p><strong>两者在生命周期上有差异。</strong>这是我的测试结果，其中hoc表示HOC返回的新的ReactComponent，app表示的是WrappedComponent：</p>\n<pre><code class=\"lang-text\">hoc componentWillMount\napp componentWillMount\napp componentDidMount\nhoc componentDidMount\n</code></pre>\n<p><em>注：这里的componentWillMount是在constructor中输出的。</em></p>\n<p>然后如果在HOC返回的新组件中更新状态的话：</p>\n<pre><code class=\"lang-text\">hoc componentWillUpdate\napp componentWillReceiveProps\napp componentWillUpdate\napp componentDidUpdate\nhoc componentDidUpdate\n</code></pre>\n<p>最后是unmount的部分：</p>\n<pre><code class=\"lang-text\">hoc componentWillUnmount\napp componentWillUnmount\n</code></pre>\n<p>大家自行和mixin比较下吧。其实得到这样的结果是很正常的，熟悉React父子组件之间生命周期关系的同学一定不会陌生。</p>\n<p><strong>暴露API的方式不同。</strong>在使用mixin时，通过会添加一个方法，比如<code>StoreListenMixin</code>提供了一个<code>this.listen</code>方法，又或者<code>react-router</code>的<code>Lifecycle</code>需要我们实现<code>routerWillLeave</code>方法。而如果是HOC的话，从开头的例子可以看出，任何API都是通过属性传递的方式传递给WrappedComponent的。</p>\n<h2 id=\"hoc-\">HOC实践</h2>\n<p>如果大家用Redux的话，<code>react-redux</code>中的connect就算是HOC了。另外，这段来自<code>react-mixin</code>的文字：</p>\n<blockquote>\n<p>90% of the time you don&#39;t need mixins, in general prefer composition via high order components. For the 10% of the cases where mixins are best (e.g. PureRenderMixin and react-router&#39;s Lifecycle mixin), this library can be very useful.</p>\n</blockquote>\n<p><code>react-router</code>始终对mixin有依赖，不过<code>react-mixin</code>提供了decorate方法，让mixin可以想HOC一样使用：</p>\n<pre><code class=\"lang-js\">@reactMixin.decorate(mixin)\nclass AnotherComponent extends Component {\n  ...\n}\n</code></pre>\n<p><a href=\"https://github.com/acdlite/recompose\">recompose</a>这个库可以关注下，里面有大量的HOC实现可以尝试尝试，这个库我也刚接触，就不多展开了。</p>\n<p>安利下我的<a href=\"https://github.com/leozdgao/react-script-loader\">react-async-script-loader</a>，用来异步加载依赖脚本的HOC，可以关注下，欢迎提issue。</p>\n<h2 id=\"-\">存在的问题</h2>\n<p>这是我在实践中遇到的两个问题，可能之后会再更新：</p>\n<p><strong>HOC导致内部ref丢失。</strong>在实践的时候，通常HOC都是“隐身”的，比如：</p>\n<pre><code class=\"lang-js\">// Editor.jsx\n@scriptLoader(...)\nclass Editor extends Component {\n  ...\n}\n\nexport default Editor\n\n// --------------------------------------\n\n// Form.jsx\nimport Editor from &#39;./Editor.jsx&#39;\n\n&lt;Editor ref=&quot;editor&quot; /&gt;\n</code></pre>\n<p>这里的<code>this.refs.editor</code>返回的是什么？注意HOC返回的是一个新的Component，所以这里的ref指向的是新的Component，那么如果你在Editor组件上定义一些public的方法的话，通过<code>this.refs.editor</code>是无法调用到的。</p>\n<p>解决办法是定义一个<code>getInnerInstance()</code>来返回内部WrappedComponent的ref，不过并不能要求第三方库的HOC都这样实现，所以这里算是有一个坑，不能算真正解决。</p>\n<p><strong>componentWillReceiveProps失控</strong>。由于HOC返回的新组件是通过给子组件传递属性的方式来传递状态的改变的，那么如果应用过多的HOC的话，可能导致<code>componentWillReceiveProps</code>里的逻辑变的难以维护。可能可以通过自己写一些utility函数来减压，不过始终是一个隐患。</p>\n<p>最后，HOC由于并不是官方解决方案，遇到坑的原因主要也是缺乏一个统一的Convention，不过观察下来HOC是大势所趋，还在持续观望中，大家对HOC有任何看法的话，欢迎交流。</p>\n<h2 id=\"-issue\">相关文章和issue</h2>\n<p><a href=\"https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md\">https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md</a>\n<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.trp9l55l0\">https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.trp9l55l0</a>\n<a href=\"https://github.com/facebook/react/issues/2669\">https://github.com/facebook/react/issues/2669</a>\n<a href=\"https://github.com/facebook/react/issues/4213\">https://github.com/facebook/react/issues/4213</a></p>\n"},{"id":"why-dom-slow","articleId":"why-dom-slow","content":"<p>一直都听说DOM很慢，要尽量少的去操作DOM，于是就想进一步去探究下为什么大家都会这样说，在网上学习了一些资料，这边整理出来。</p>\n<p>首先，DOM对象本身也是一个js对象，所以严格来说，并不是操作这个对象慢，而是说操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）。下面主要先介绍下这些浏览器行为，阐述一个页面是怎么最终被呈现出来的，另外还会从代码的角度，来说明一些不好的实践以及一些优化方案。</p>\n<!-- more -->\n<h2 id=\"-\">浏览器是如何呈现一张页面的</h2>\n<p>一个浏览器有许多模块，其中负责呈现页面的是渲染引擎模块，比较熟悉的有WebKit和Gecko等，这里也只会涉及这个模块的内容。</p>\n<p>先用文字大致阐述下这个过程：</p>\n<ul>\n<li>解析HTML，并生成一棵<strong>DOM tree</strong></li>\n<li>解析各种样式并结合DOM tree生成一棵<strong>Render tree</strong></li>\n<li>对Render tree的各个节点计算布局信息，比如box的位置与尺寸</li>\n<li>根据Render tree并利用浏览器的UI层进行绘制</li>\n</ul>\n<p>其中DOM tree和Render tree上的节点并非一一对应，比如一个<code>display:none</code>的节点就在会存在与DOM tree上，而不会出现在Render tree上，因为这个节点不需要被绘制。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/005YR2J3jw1eys88jq2soj30hc081t99.jpg\" alt=\"\"></p>\n<p>上图是Webkit的基本流程，在术语上和Gecko可能会有不同，这里贴上Gecko的流程图，不过文章下面的内容都会统一使用Webkit的术语。</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/005YR2J3jw1eys89gjdkmj30hc082jru.jpg\" alt=\"\"></p>\n<p>影响页面呈现的因素有许多，比如link的位置会影响首屏呈现等。但这里主要集中讨论与layout相关的内容。</p>\n<p>paint是一个耗时的过程，然而layout是一个更耗时的过程，我们无法确定layout一定是自上而下或是自下而上进行的，甚至一次layout会牵涉到整个文档布局的重新计算。</p>\n<p>但是<strong>layout是肯定无法避免的</strong>，所以我们主要是<strong>要最小化layout的次数。</strong></p>\n<h2 id=\"-layout\">什么情况下浏览器会进行layout</h2>\n<p>在考虑如何最小化layout次数之前，要先了解什么时候浏览器会进行layout。</p>\n<p><strong>layout（reflow）一般被称为布局</strong>，这个操作是用来计算文档中元素的位置和大小，是渲染前重要的一步。在HTML第一次被加载的时候，会有一次layout之外，js脚本的执行和样式的改变同样会导致浏览器执行layout，这也是本文的主要要讨论的内容。</p>\n<p>一般情况下，浏览器的layout是lazy的，也就是说：在js脚本执行时，是不会去更新DOM的，任何对DOM的修改都会被暂存在一个队列中，在当前js的执行上下文完成执行后，会根据这个队列中的修改，进行一次layout。</p>\n<p>然而有时希望在js代码中立刻获取最新的DOM节点信息，浏览器就不得不提前执行layout，这是导致DOM性能问题的主因。</p>\n<p>如下的操作会打破常规，并触发浏览器执行layout：</p>\n<ul>\n<li>通过js获取需要计算的DOM属性</li>\n<li>添加或删除DOM元素</li>\n<li>resize浏览器窗口大小</li>\n<li>改变字体</li>\n<li>css伪类的激活，比如:hover</li>\n<li>通过js修改DOM元素样式且该样式涉及到尺寸的改变</li>\n</ul>\n<p>我们来通过一个例子直观的感受下：</p>\n<pre><code class=\"lang-javascript\">// Read\nvar h1 = element1.clientHeight;\n\n// Write (invalidates layout)\nelement1.style.height = (h1 * 2) + &#39;px&#39;;\n\n// Read (triggers layout)\nvar h2 = element2.clientHeight;\n\n// Write (invalidates layout)\nelement2.style.height = (h2 * 2) + &#39;px&#39;;\n\n// Read (triggers layout)\nvar h3 = element3.clientHeight;\n\n// Write (invalidates layout)\nelement3.style.height = (h3 * 2) + &#39;px&#39;;\n</code></pre>\n<p>这里涉及一个属性<code>clientHeight</code>，这个属性是需要计算得到的，于是就会触发浏览器的一次layout。我们来利用chrome（v47.0）的开发者工具看下（截图中的timeline record已经经过筛选，仅显示layout）：</p>\n<p><img src=\"http://ww3.sinaimg.cn/large/005YR2J3jw1eys8afxowtj312211otf6.jpg\" alt=\"\"></p>\n<p>上面的例子中，代码首先修改了一个元素的样式，接下来读取另一个元素的<code>clientHeight</code>属性，由于之前的修改导致当前DOM被标记为脏，为了保证能准确的获取这个属性，浏览器会进行一次layout（我们发现chrome的开发者工具良心的提示了我们这个性能问题）。</p>\n<p>优化这段代码很简单，预先读取所需要的属性，在一起修改即可。</p>\n<pre><code class=\"lang-javascript\">// Read\nvar h1 = element1.clientHeight;\nvar h2 = element2.clientHeight;\nvar h3 = element3.clientHeight;\n\n// Write (invalidates layout)\nelement1.style.height = (h1 * 2) + &#39;px&#39;;\nelement2.style.height = (h2 * 2) + &#39;px&#39;;\nelement3.style.height = (h3 * 2) + &#39;px&#39;;\n</code></pre>\n<p>看下这次的情况：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/005YR2J3jw1eys8bk9aurj312211o79n.jpg\" alt=\"\"></p>\n<p>下面再介绍一些其他的优化方案。</p>\n<h2 id=\"-layout-\">最小化layout的方案</h2>\n<p>上面提到的一个批量读写是一个，主要是因为获取一个需要计算的属性值导致的，那么哪些值是需要计算的呢？</p>\n<p>这个链接里有介绍大部分需要计算的属性：<a href=\"http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html\">http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html</a></p>\n<p>再来看看别的情况：</p>\n<h3 id=\"-dom-\">面对一系列DOM操作</h3>\n<p>针对一系列DOM操作（DOM元素的增删改），可以有如下方案：</p>\n<ul>\n<li>documentFragment</li>\n<li>display: none</li>\n<li>cloneNode</li>\n</ul>\n<p>比如（仅以documentFragment为例）：</p>\n<pre><code class=\"lang-javascript\">var fragment = document.createDocumentFragment();\nfor (var i=0; i &lt; items.length; i++){\n  var item = document.createElement(&quot;li&quot;);\n  item.appendChild(document.createTextNode(&quot;Option &quot; + i);\n  fragment.appendChild(item);\n}\nlist.appendChild(fragment);\n</code></pre>\n<p>这类优化方案的核心思想都是相同的，就是<strong>先对一个不在Render tree上的节点进行一系列操作，再把这个节点添加回Render tree，这样无论多么复杂的DOM操作，最终都只会触发一次layout</strong>。</p>\n<h3 id=\"-\">面对样式的修改</h3>\n<p>针对样式的改变，我们首先需要知道<strong>并不是所有样式的修改都会触发layout</strong>，因为我们知道layout的工作是计算RenderObject的尺寸和大小信息，那么我如果只是改变一个颜色，是不会触发layout的。</p>\n<p>这里有一个网站<a href=\"http://csstriggers.com/\">CSS triggers</a>，详细列出了各个CSS属性对浏览器执行layout和paint的影响。</p>\n<p>像下面这种情况，和上面讲优化的部分是一样的，注意下读写即可。</p>\n<pre><code class=\"lang-javascript\">elem.style.height = &quot;100px&quot;; // mark invalidated\nelem.style.width = &quot;100px&quot;;\nelem.style.marginRight = &quot;10px&quot;;\n\nelem.clientHeight // force layout here\n</code></pre>\n<p>但是要提一下动画，这边讲的是js动画，比如：</p>\n<pre><code class=\"lang-javascript\">function animate (from, to) {\n  if (from === to) return\n\n  requestAnimationFrame(function () {\n    from += 5\n    element1.style.height = from + &quot;px&quot;\n    animate(from, to)\n  })\n}\n\nanimate(100, 500)\n</code></pre>\n<p>动画的每一帧都会导致layout，这是无法避免的，但是为了减少动画带来的layout的性能损失，可以将动画元素绝对定位，这样动画元素脱离文本流，layout的计算量会减少很多。</p>\n<h3 id=\"-requestanimationframe\">使用requestAnimationFrame</h3>\n<p>任何可能导致重绘的操作都应该放入<code>requestAnimationFrame</code></p>\n<p>在现实项目中，代码按模块划分，很难像上例那样组织批量读写。那么这时可以把写操作放在<code>requestAnimationFrame</code>的callback中，统一让写操作在下一次paint之前执行。</p>\n<pre><code class=\"lang-javascript\">// Read\nvar h1 = element1.clientHeight;\n\n// Write\nrequestAnimationFrame(function() {\n  element1.style.height = (h1 * 2) + &#39;px&#39;;\n});\n\n// Read\nvar h2 = element2.clientHeight;\n\n// Write\nrequestAnimationFrame(function() {\n  element2.style.height = (h2 * 2) + &#39;px&#39;;\n});\n</code></pre>\n<p><img src=\"http://ww1.sinaimg.cn/large/005YR2J3jw1eys8c9d4quj312211owll.jpg\" alt=\"\"></p>\n<p>可以很清楚的观察到Animation Frame触发的时机，MDN上说是在paint之前触发，不过我估计是在js脚本交出控制权给浏览器进行DOM的invalidated check之前执行。</p>\n<h2 id=\"-\">其他注意点</h2>\n<p>除了由于触发了layout而导致性能问题外，这边再列出一些其他细节：</p>\n<p>缓存选择器的结果，减少DOM查询。这里要特别体下HTMLCollection。HTMLCollection是通过<code>document.getElementByTagName</code>得到的对象类型，和数组类型很类似但是<strong>每次获取这个对象的一个属性，都相当于进行一次DOM查询</strong>：</p>\n<pre><code class=\"lang-javascript\">var divs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; divs.length; i++){  //infinite loop\n  document.body.appendChild(document.createElement(&quot;div&quot;));\n}\n</code></pre>\n<p>比如上面的这段代码会导致无限循环，所以处理HTMLCollection对象的时候要最些缓存。</p>\n<p>另外减少DOM元素的嵌套深度并优化css，去除无用的样式对减少layout的计算量有一定帮助。</p>\n<p>在DOM查询时，<code>querySelector</code>和<code>querySelectorAll</code>应该是最后的选择，它们功能最强大，但执行效率很差，如果可以的话，尽量用其他方法替代。</p>\n<p>下面两个jsperf的链接，可以对比下性能。</p>\n<p><a href=\"https://jsperf.com/getelementsbyclassname-vs-queryselectorall/162\">https://jsperf.com/getelementsbyclassname-vs-queryselectorall/162</a>\n<a href=\"http://jsperf.com/getelementbyid-vs-queryselector/218\">http://jsperf.com/getelementbyid-vs-queryselector/218</a></p>\n<h2 id=\"-view-\">自己对View层的想法</h2>\n<p>上面的内容理论方面的东西偏多，从实践的角度来看，上面讨论的内容，正好是View层需要处理的事情。已经有一个库FastDOM来做这个事情，不过它的代码是这样的：</p>\n<pre><code class=\"lang-javascript\">fastdom.read(function() {\n  console.log(&#39;read&#39;);\n});\n\nfastdom.write(function() {\n  console.log(&#39;write&#39;);\n});\n</code></pre>\n<p>问题很明显，会导致<code>callback hell</code>，并且也可以预见到像FastDOM这样的imperative的代码缺乏扩展性，关键在于用了<code>requestAnimationFrame</code>后就变成了异步编程的问题了。要让读写状态同步，那必然需要在DOM的基础上写个Wrapper来内部控制异步读写，不过都到了这份上，感觉可以考虑直接上React了......</p>\n<p>总之，尽量注意避免上面说到的问题，但如果用库，比如jQuery的话，layout的问题出在库本身的抽象上。像React引入自己的组件模型，用过virtual DOM来减少DOM操作，并可以在每次state改变时仅有一次layout，我不知道内部有没有用<code>requestAnimationFrame</code>之类的，感觉要做好一个View层就挺有难度的，之后准备学学React的代码。希望自己一两年后会过来再看这个问题的时候，可以有些新的见解。</p>\n<h2 id=\"-\">参考</h2>\n<ul>\n<li><a href=\"http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\">http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a></li>\n<li><a href=\"https://dev.opera.com/articles/efficient-javascript/?page=3\">https://dev.opera.com/articles/efficient-javascript/?page=3</a></li>\n<li><a href=\"http://wilsonpage.co.uk/preventing-layout-thrashing/\">http://wilsonpage.co.uk/preventing-layout-thrashing/</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/\">https://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/</a></li>\n<li><a href=\"http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html\">http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html</a></li>\n</ul>\n"},{"id":"write-yeoman-generator","articleId":"write-yeoman-generator","content":"<p>由于自己经常会写一些 demo，或者学习新工具库的使用，然后又比较依赖 npm 的模块管理（这个是重点）和 webpack 的代码打包功能，所以每次都要创建一个目录结构，复制各种 <code>.rc</code> 文件，复制 webpack 的配置文件，复制一个应用了 webpack dev 中间件的 express server，每次都要这样，让我心里很烦。</p>\n<p>我一直知道 yeoman 这个东西，不过找不到自己喜欢的 generator，简单浏览过 generator 的文档，感觉很麻烦，不易上手，就一直没学。最近在新的项目组，我又定义了一套开发的目录规范，为了给自己和团队的其他人提供开发上的便利，于是决定好好学写 Yeoman Generator。</p>\n<p>本文将介绍一个基本的 Yeoman Generator 的写法，并分享一些开发中的注意点。</p>\n<!-- more -->\n<h2 id=\"yeoman-\">Yeoman 是干什么的？</h2>\n<p>简单介绍下 Yeoman，它是一个脚手架生成工具，比如在之前写 ASP.NET MVC 的时候，Visual Studio 会给你选模板，然后生成一个项目的基本结构（脚手架），这对提升开发体验是很有帮助的，节省了重复劳动。然而前端没有什么 IDE（WebStorm？或许吧），没有一个固定的开发模式，可能你喜欢 jshint，我想用 eslint，你觉得 angular 顺手，我觉得 vue 更合适，这时就可以使用 Yeoman 这个工具，生成一个 <strong>适合自己技术栈</strong> 的脚手架，需要的一些文件都预先生成好，给自己省点事。</p>\n<p>而 Yeoman Generator 则定义了一个脚手架应该如何生成，所以我们可以去 <a href=\"http://yeoman.io/generators/\">这个网站</a> 找适合自己的 Generator，如果没有的话，就自己动手吧。</p>\n<p>然后这里是安装和使用的命令，不具体介绍它的使用了，想学的话可以去 <a href=\"http://yeoman.io/\">它的官网</a> 看看。</p>\n<pre><code class=\"lang-shell\">&gt; npm install -g yo\n&gt; npm install -g generator-angular\n\n&gt; yo angular\n</code></pre>\n<h2 id=\"-\">自己的需求</h2>\n<p>先说下自己的需求吧，我希望它可以：</p>\n<ul>\n<li>满足自己的技术栈：express、webpack、react、babel、eslint、travis</li>\n<li>自动生成并安装依赖</li>\n<li>灵活性，即可以生成一个适合写 demo 的小脚手架，也可以生成一个 WebApp 的复杂脚手架，同时，在需要的时候可以只生成一份 <code>.babelrc</code></li>\n<li>组合性，多个脚手架可以组合，可复用</li>\n</ul>\n<p>很高兴的是，Yeoman 完全可以实现我的需求。</p>\n<h2 id=\"-yeoman-generator-\">开始写 Yeoman Generator 了</h2>\n<p>Yeoman 给我们提供了一个用来写脚手架的脚手架 <a href=\"https://github.com/yeoman/generator-generator\">generator-generator</a>，我们可以从它开始。</p>\n<blockquote>\n<p>由于生成出来的项目依赖 nsp 服务，我在 npm prepublish 阶段的时候发生了域名解析错误的问题，如果遇到了类似的问题，就把 package.json 里的 prepublish 删掉吧。</p>\n</blockquote>\n<p>假设我要写一个 Generator 叫做 Butler（管家的意思），那么，根据 Yeoman 的规定，你需要将这个 node 模块的名字命名为 <code>generator-*</code>，所以我命名为 <code>generator-butler</code>，如果你是通过 <code>generator-generator</code> 生成的目录结构，那么可以进入到 <code>generator-butler</code> 目录中，运行 <code>npm link</code>，就可以开始使用你的 Generator 啦。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005YR2J3gw1f0y6nfy1btj31340n5gp0.jpg\" alt=\"\"></p>\n<p>Yeoman Generator 高度依赖目录结构，意思是它的行为由你的目录结构决定，怎么说？比如：</p>\n<pre><code class=\"lang-shell\">yo butler\nyo butler:babel\n</code></pre>\n<p>第一条命令会找你代码目录中的 <code>app</code> 目录，第二条命令会找你目录中的 <code>babel</code> 目录。这样的一个个目录称为 <code>sub-generator</code>，默认的 <code>sub-generator</code> 名字是 app。</p>\n<p>为什么要这样呢？我分享我的想法，我觉得这是出于对可组合性角度考虑的，我们可以定义多个 <code>sub-generator</code>，比如我有多个 <code>sub-generator</code> 分别单独管理：babel、eslint、webpack，同时 app 这个默认的 <code>sub-generator</code> 是这几个 <code>sub-generator</code> 的组合，所以：</p>\n<ul>\n<li>同时可以生成整个项目的结构，也可以（比如）只生成 babel 配置文件</li>\n<li>各个模块单独管理，易于维护</li>\n</ul>\n<p>非常符合自己比较认同的一句话：</p>\n<blockquote>\n<p>perfer composition over inheritance</p>\n</blockquote>\n<p>默认 <code>sub-generator</code> 是基于项目根目录找的，也可以换一个目录（比如 generators），就像例子中那样统一管理，要实现这个，需要在 <code>package.json</code> 中加一个属性：</p>\n<pre><code class=\"lang-json\">{\n  ...\n  &quot;files&quot;: [\n    &quot;generators&quot;\n  ],\n  ...\n}\n</code></pre>\n<p>如何实现组合，下面会说到。</p>\n<blockquote>\n<p>sub-generator 的加载似乎并不是直接应用 node 的模块 resolve 机制，我本来以为是一个文件夹模块加载方式，我试着直接创建文件模块，它就不认了，看来是必须使用文件夹模块的方式的。</p>\n</blockquote>\n<h3 id=\"-\">基本结构</h3>\n<p>Yeoman 为我们提供了 Generator 的基类，于是：</p>\n<pre><code class=\"lang-js\">var generators = require(&#39;yeoman-generator&#39;)\n\nmodule.exports = generators.Base.extend({\n  constructor: function () {\n    generators.Base.apply(this, arguments)\n\n    // your logic\n  }\n})\n</code></pre>\n<blockquote>\n<p>这边用的 OOP 用的是 <code>classical inheritance</code> 的风格，使用了 <a href=\"https://github.com/SBoudrias/class-extend\">class-extend</a> 这个模块，有兴趣的可以看看。</p>\n</blockquote>\n<p>我们需要做的就是定义它的方法就行了。那么要怎么定义呢？</p>\n<h3 id=\"-\">运行周期</h3>\n<p>一个 Yeoman Generator 被创建后（构造函数必然是最先被调用的），会依次调用它原型上的方法，且每一个方法中的 this 都被绑定为 Generator 实例本身，调用的顺序如下：</p>\n<ol>\n<li><strong>initializing</strong> - 初始化一些状态之类的，通常是和用户输入的 <code>options</code> 或者 <code>arguments</code> 打交道，这个后面说。</li>\n<li><strong>prompting</strong> - 和用户交互的时候（命令行问答之类的）调用。</li>\n<li><strong>configuring</strong> - 保存配置文件（如 <code>.babelrc</code> 等）。</li>\n<li><strong>default</strong> - 其他方法都会在这里按顺序统一调用。</li>\n<li><strong>writing</strong> - 在这里写一些模板文件。</li>\n<li><strong>conflicts</strong> - 处理文件冲突，比如当前目录下已经有了同名文件。</li>\n<li><strong>install</strong> - 开始安装依赖。</li>\n<li><strong>end</strong> - 擦屁股的部分... Say Goodbye maybe...</li>\n</ol>\n<p>上面只是调用顺序，后面的说明是建议，也就是说你完全可以在 <strong>install</strong> 的部分写文件，在 <strong>configuring</strong> 的时候就开始安装依赖，不过这样的话，就不保证行为的正确性了，更不要说维护上的问题了，所以，别这样，按照它的强制范式来吧。</p>\n<p>这些运行周期方法，除了可以是函数外，还可以是对象，我以 babel 的 <code>sub-generator</code> 为例子：</p>\n<pre><code class=\"lang-js\">writing: {\n  files: function () {\n    // 写 `.babelrc` 文件\n  },\n  pkg: function () {\n    // 给 package.json 文件上添加依赖项\n  }\n}\n</code></pre>\n<p>对象里的每一个函数会被依次执行。是写成一个函数，还是分成多个函数写成一个对象，都可以，我个人倾向于后者。</p>\n<p><strong>关于依赖 Object 属性的顺序</strong></p>\n<p>偏一下题，注意 default 这个部分，【按顺序执行】？</p>\n<p>首先从 ECMAScript 标准来说，并不保证对象属性的顺序，之前开发遇到过坑：</p>\n<blockquote>\n<p>4.3.3 Object\nAn object is a member of the type Object. It is <strong>an unordered collection</strong> of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.</p>\n</blockquote>\n<p>自己在写 Generator 的时候也没怎么自定义方法（就是 default 这步是空的），都是依赖它的运行周期函数，而 Yeoman Generator 目前是依赖于对象属性的插入顺序的（相当于运行到 default 这步的时候），这里不多评价，如果平时开发希望在遍历集合的时候，保证遍历顺序的话，应该使用数组或者是ECMAScript 2015 中新增的 Map 对象：</p>\n<blockquote>\n<p>A Map iterates its elements in insertion order, whereas iteration order is not specified for Objects.</p>\n</blockquote>\n<h3 id=\"-\">和用户的交互</h3>\n<p>Yeoman 提供了多个方式来灵活定制你的脚手架：</p>\n<p><strong>Arguments 和 Options</strong></p>\n<p>比如：</p>\n<blockquote>\n<p>yo butler MyProject --react --author leozdgao</p>\n</blockquote>\n<p>其中，<code>MyProject</code> 就一个第一个定义的 argument，而 <code>react</code> 和 <code>author</code> 就是 options，值分别是 true 和 leozdgao。</p>\n<p>对于 arguments 来说，不需要输入 key，键值对的对应关系是根据定义顺序来的。对于 options 来说，可以分别出入 key 和 value。</p>\n<p>定义 arguments 和 options 的方式是类似的：</p>\n<pre><code class=\"lang-js\">this.option(&#39;react&#39;, {\n  type: Boolean,\n  desc: &quot;need to use React or not.&quot;,\n  defaults: false\n})\nthis.arguments(&#39;name&#39;, {\n  type: String,\n  desc: &quot;your project name&quot;,\n  required: true\n})\n</code></pre>\n<p>从参数名上就看的明白是什么意思了，不多说了。</p>\n<p>定义 arguments 或者 options 写在哪里都行，不过为了保证在任何地方都能正常访问到，建议放在构造函数中。如果要访问的话：</p>\n<pre><code class=\"lang-js\">this.options[&#39;react&#39;] // options 通过 options 属性获取\nthis.name // 是的，arguments 会直接作为 generator 的一个属性\n</code></pre>\n<p>arguments 和 options 的帮助信息会在定义后自动生成（如果它们不是在构造函数中被定义的话，帮助信息就无法自动生成）：</p>\n<pre><code class=\"lang-shell\">&gt; yo butler --help\n</code></pre>\n<blockquote>\n<p>不要信你定义的 <code>type</code>，其实这里并没有根据你定义的 <code>type</code> 进行转换，如果对数据类型有要求的话，这里要当心。</p>\n</blockquote>\n<p><strong>CLI 交互</strong></p>\n<p>使用与用户问答交互的方式是比较有趣的，同时也不用记住要传的参数，Yeoman 提供了 API 来让我们快速实现 CLI 交互：</p>\n<pre><code class=\"lang-js\">module.exports = generators.Base.extend({\n  prompting: function () {\n    var done = this.async();\n    this.prompt({\n      type    : &#39;input&#39;,\n      name    : &#39;name&#39;,\n      message : &#39;Your project name&#39;,\n      default : this.appname // Default to current folder name\n    }, function (answers) {\n      this.log(answers.name);\n      done();\n    }.bind(this));\n  }\n});\n</code></pre>\n<p>内部直接使用了 <code>Inquirer.js</code>，API不变，这里就不多写了，大家可以直接看 <a href=\"https://github.com/SBoudrias/Inquirer.js\">文档</a>。</p>\n<blockquote>\n<p>可以发现 Yeoman 处理异步的方式是声明回调并显示调用。</p>\n</blockquote>\n<h3 id=\"-\">项目模板</h3>\n<p>生成脚手架就是拷贝模板文件，你可以定义你的模板文件。这里涉及到两个文件夹，一个是你希望生成脚手架的目标文件夹，一个是模板所在的文件夹。Yeoman 提供了 API 来快速获取它们，来看个例子，我希望根据 <code>react</code> 这个 option 来决定是否在 presets 中添加 <code>react</code>：</p>\n<pre><code class=\"lang-js\">writing: function () {\n  this.fs.copyTpl(\n    this.templatePath(&#39;.babelrc&#39;),\n    this.destinationPath(&#39;.babelrc&#39;),\n    { needReact: this.options.react }\n  )\n}\n</code></pre>\n<p>获取目标文件夹目录可以用 <code>generator.destinationPath()</code>，传入的参数和 <code>path.join()</code> 是一样的。获取模板文件夹目录可以用 <code>generator.sourceRoot()</code>，默认是 Generator 代码目录下的 <code>./templates</code>，也可以重写：<code>generator.sourceRoot(&#39;new/template/path&#39;)</code>。如果是拼模板文件路径的话，就用 <code>generator.templatePath(&#39;app/index.js&#39;)</code>。</p>\n<p>Yeoman 给我们提供了方便的处理文件的工具，可以通过 <code>fs</code> 属性调用，其实就是用了 <a href=\"https://github.com/sboudrias/mem-fs-editor\">mem-fs-editor</a> 这个库，可以直接看它的 API 说明，这里不多说了，要提一下的是模板引擎用的时 EJS。</p>\n<p>这份是我对应上面例子的模板文件：</p>\n<pre><code class=\"lang-json\">{\n  &quot;presets&quot;: [\n    &quot;es2015&quot;, &quot;stage-0&quot;\n    &lt;% if (needReact) { %&gt;\n    , &quot;react&quot;\n    &lt;% } %&gt;\n  ]\n}\n</code></pre>\n<p>例子里调用了 <code>copyTpl</code>，如果觉得不用经过模板引擎，可以直接用 <code>copy</code> 原样拷贝。</p>\n<h3 id=\"-\">组合</h3>\n<blockquote>\n<p>这里的组合只是概念，并不是按照函数式的方式实现的。</p>\n</blockquote>\n<p>要实现组合，其实很简单，在希望调用的地方调用 <code>generator.composeWith</code> 即可，直接上例子：</p>\n<pre><code class=\"lang-js\">default: function () {\n  // execute other sub-generators\n  this.composeWith(&#39;butler:babel&#39;, {\n    options: { react: this.options.react }\n  }, {\n    local: require.resolve(&#39;../babel&#39;)\n  })\n  // select a License\n  this.composeWith(&#39;license&#39;, {\n    options: {\n      name: this.props.authorName,\n      email: this.props.authorEmail,\n      website: this.props.authorUrl\n    }\n  }, {\n    local: require.resolve(&#39;generator-license/app&#39;)\n  })\n}\n</code></pre>\n<p>例子里分别是组合本地的一个 <code>sub-generator</code>，和一个外部的 <code>Generator</code>，我选择在 default 这个运行周期调用组合。</p>\n<p>composeWith 接受三个参数，第一个参数一个名字，写什么都行，不过最好写要被组合的 <code>Generator</code> 的名字。第二个参数是传入 <code>options</code> 和 <code>arguments</code>。第三个参数 settings，只用 local 和 link 两个选项，local 是用来定位要组合的 <code>Generator</code> 的位置的，link 还不知道，没怎么看懂它的 <a href=\"http://yeoman.io/generator/Base.html\">说明文档</a>。</p>\n<h3 id=\"-\">自动安装依赖</h3>\n<p>恩，差点忘记这个，很简单，就是函数调用：</p>\n<pre><code class=\"lang-js\">install: function() {\n  this.npmInstall([ &#39;lodash&#39; ], { &#39;saveDev&#39;: true });\n}\n</code></pre>\n<p>在任何地方调用都是可以的，Yeoman 会统一在进入 install 阶段的时候统一执行。如果还有在用 bower 的同学的话可以用这个：<code>generator.bowerInstall()</code>。</p>\n<h2 id=\"-\">最后</h2>\n<p>好了，基本上完了，如果什么地方写错了，还望指出。自己的 <a href=\"https://github.com/leozdgao/butler\">butler</a>，还在开发中，可以参考，另外我其实也是参考 <a href=\"https://github.com/yeoman/generator-node\">generator-node</a> 的，或者自己找些 Yeoman Generator 的源码学学，个人认为使用 npm 作为包管理是趋势（暂时也应该没有终极方案，还是要依赖 bundle 工具），那么 bundle 工具就是不可或缺的了，写个脚手架还是挺有帮助的，希望本文对大家有帮助。</p>\n<p>然后是一些工具库推荐：</p>\n<ul>\n<li><a href=\"https://github.com/jozefizso/generator-license\">generator-license</a> - 选择 License 的 Generator</li>\n<li><a href=\"https://github.com/SBoudrias/Inquirer.js\">inquirer</a> - 提供命令行交互的工具</li>\n<li><a href=\"https://github.com/SBoudrias/inquirer-npm-name\">inquirer-npm-name</a> - 帮助查询模块名在 npm 上是否冲突，和 Yeoman 完美融合</li>\n<li><a href=\"https://github.com/yeoman/yosay\">yosay</a> - 在命令行输出信息的时候，同时输出 Yeoman 的卡通人物...</li>\n</ul>\n<p>一些文档的链接：</p>\n<ul>\n<li><a href=\"http://yeoman.io/generator/Base.html\">Yeoman Generator API</a></li>\n<li><a href=\"http://yeoman.io/authoring/\">Get Started</a></li>\n<li><a href=\"http://yeoman.io/\">Yeoman 官网</a></li>\n</ul>\n<p>Yeoman 团队目前在开发一个 <a href=\"https://github.com/yeoman/yeoman-app\">Yeoman App</a>，就是一个 GUI 版的 yo 吧，总之还是期待的。</p>\n"}]}